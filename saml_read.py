#!/usr/bin/env python3
#-*- coding: utf-8 -*-
#-----------------------------------------------------------------------------
# Name:        saml_read.py
# Purpose:     Read SAML response   
#-----------------------------------------------------------------------------

import base64
import xml.etree.ElementTree as ET
import optparse
import sys
from Crypto.Cipher import AES
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from urllib.parse import unquote


def DecryptSharedKey(priv_key, enc_shared_key):
    """ 
    Decrypt the shared key generated by the IDP. The key is 
    encrypted with the RSA-OAEP algorithm and the public key
    from the SP.
    """ 
    try:
        pkey = RSA.importKey(open(priv_key).read())
        cipher = PKCS1_OAEP.new(pkey)
        return cipher.decrypt(enc_shared_key)
    except Exception as e:
        sys.exit('Failed to decrypt the shared key: %s(%s)\n' % (e.__class__.__name__, e))

def AESDecrypt(shared_key, enc_assertion):
    """ 
    Decrypt the encrypted assertion. The last is made up of a 16 bytes
    initialisation vector followed by the cipher-assertion. See RFC3602.
    """
    try:
        iv = enc_assertion[:16]
        enc_msg = enc_assertion[16:]
        cipher = AES.new(shared_key, AES.MODE_CBC, iv)
        return cipher.decrypt(enc_msg)
    except Exception as e:
        sys.exit('Failed to decrypt assertion: %s(%s)\n' % (e.__class__.__name__, e))

def DecryptAssertion(data, verbose=False):
    """ 
    Decrypt the shared key generated by the IDP using the SP public key, then
    decrypt the assertion with it.
    """
    # Load SAML response
    tree = ET.ElementTree(ET.fromstring(data))
    root = tree.getroot()

    # Namespaces
    NS_DS="{%s}" % "http://www.w3.org/2000/09/xmldsig#" 
    NS_SAML="{%s}" % "urn:oasis:names:tc:SAML:2.0:assertion" 
    NS_XENC="{%s}" % "http://www.w3.org/2001/04/xmlenc#"

    # Encrypted assertion 
    data = root.find('.//' + NS_SAML + 'EncryptedAssertion/' + NS_XENC + 'EncryptedData')
    enc_assertion_method = data.find(NS_XENC + 'EncryptionMethod').attrib['Algorithm'].split('#')[1]
    enc_assertion_cipher = data.find(NS_XENC + 'CipherData/' + NS_XENC + 'CipherValue').text

    # Shared key used to encrypt the assertion 
    enc_key = data.find(NS_DS + 'KeyInfo/' + NS_XENC + 'EncryptedKey')
    enc_key_method = enc_key.find(NS_XENC + 'EncryptionMethod').attrib['Algorithm'].split('#')[1]
    enc_key_digest = enc_key.find(NS_XENC + 'EncryptionMethod/' + NS_DS + 'DigestMethod').attrib['Algorithm'].split('#')[1]
    enc_key_cipher = enc_key.find(NS_XENC + 'CipherData/' + NS_XENC + 'CipherValue').text

    if verbose:
        print('\033[4mShared key\033[0m : \n')
        print('  - Encryption method : %s' % enc_key_method)
        print('  - Digest method : %s' % enc_key_digest)
        print('  - Key cipher value : %s\n' % enc_key_cipher)
        print('\033[4mEncrypted assertion\033[0m : \n')
        print('  - Encryption method : %s' % enc_assertion_method)
        print('  - Encrypted assertion : %s\n' % enc_assertion_cipher)

    print('\n\033[4mDecrypted SAML response\033[0m : \n')
    # Decrypt shared key
    shared_key = DecryptSharedKey(priv_key, base64.b64decode(enc_key_cipher))

    # Decrypt Assertion
    assertion = AESDecrypt(shared_key, base64.b64decode(enc_assertion_cipher))
    print('%s' % assertion)

def GetAssertion(response):
    """ 
    Decode SAML assertion 
    """
    if response.startswith('SAMLResponse'):
        response = response.split('=')[1]

    if response.startswith('PHNhbWxwOlJlc3BvbnNlIE'):
        # add three '=' to the response to avoid incorrect padding
        assertion = base64.b64decode(unquote(response + '==='))
    elif response.find('<samlp:Response') != -1:
        assertion = response
    else:
        sys.exit('Invalid SAML response')
    return assertion


if __name__ == '__main__':
    parser = optparse.OptionParser("%prog saml_response\n       %prog -f samlresponse.txt -d -k myprivate.key.pem")
    parser.add_option('-f', dest='file', help="SAML response file")
    parser.add_option('-d', action="store_true", dest='decrypt', help="Decrypt assertion")
    parser.add_option('-k', dest='priv_key', help="Certificate's private key file encoded in standard form")
    parser.add_option('-v', action="store_true", dest='verbose', help="verbose")
    options, args = parser.parse_args()

    if len(args) not in [1] and not options.file:
        parser.error("Incorrect number of arguments\n")

    if options.file:
        with open(options.file, 'r') as f:
            response = f.read()
    else:
        response = args[0]

    assertion = GetAssertion(response)
    print('\n\033[4mSAML response\033[0m : \n')
    print('%s' % assertion)

    if options.decrypt:
        if not options.priv_key:
            parser.error("Private key is mandatory")
        priv_key = options.priv_key
        DecryptAssertion(assertion, options.verbose)

